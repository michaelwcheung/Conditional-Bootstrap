cate_se=numeric())
# if conducting bootstrap hypothesis test, instantiate storage structure for observed CATEs
if (test=="BH") {
bh_cates <- tibble(quantile=numeric(),
em=character(),
o_cate=numeric(),
o_cate_se=numeric())
}
# compute full data ATE
if (estimand=="or") {
ate_mod <- glm(y ~ z + as.matrix(X), family=binomial)
ate <- exp(ate_mod$coefficients["z"])
ate_confint <- exp(confint(ate_mod)["z", 1:2])
} else if (estimand=="rd") {
ate_mod <- lm(y ~ z + as.matrix(X))
ate <- ate_mod$coefficients["z"]
ate_confint <- confint(ate_mod)["z", 1:2]
} else {}
lm(y ~ z + as.matrix(X))
names(X)
ate_mod$coefficients
ate_mod$coefficients["z"]
confint(ate_mod)
ate_confint
# method to be run locally for the purposes of testing parallel processing
libraries <- c("DT", "tidyverse", "WeightIt", "sandwich", "lmtest", "boot", "plotly", "promises", "future", "foreach", "doFuture", "progressr", "data.table", "parallel", "future.apply", "stringr", "dplyr")
lapply(libraries, require, character.only = TRUE)
getwd()
setwd("~/benmarhnia-lab/Conditional-Bootstrap/parallel/")
# source files
source("../helper-functions.R")
source("create_ems.R")
# source files
source("../helper-functions.R")
source("create_ems.R")
# load in data/parameters
data <- read_csv("~/benmarhnia-lab/data_droughts_malnutrition_101822.csv")
y <- pull(data, stunted)
z <- pull(data, drought)
X <- select(data, -c(stunted, drought))
P <- select(X, education_none, mass_media, rural_residence)
View(P)
quantiles <- c(0, 50, 100)
B <- 1
estimand <- "rd"
estimation_method <- "lr"
test <- "BH"
alpha <- 0.05
if (estimand == "or") {
family <- "binomial"
} else if (estimand == "rd") {
family <- "gaussian"
} else {}
if (estimation_method == "iptw" | estimation_method == "dr") {
propensity <- ipweights(data, X, z)
} else if (estimation_method == "lr") {
propensity <- rep(1, length(z))
} else {}
# create ems and clean P
create_ems_output = create_ems(P)
create_ems_output[2]
# create ems and clean P
create_ems_output = create_ems(P)
View(create_ems_output)
source("create_ems.R")
# create ems and clean P
create_ems_output = create_ems(P)
create_ems_output["P"]
P = create_ems_output["P"]
ems = create_ems_output["ems"]
fut_globals <- list(
data = data, y = y, z = z, X = X, P = P, ems = ems,
quantiles = quantiles, B = B, estimand = estimand, test = test, estimation_method = estimation_method, alpha = alpha, family = family, propensity = propensity,
bse = bse, cochrans_q_het = cochrans_q_het, ipweights = ipweights, generate_adj_X = generate_adj_X, estimate_ate = estimate_ate, estimate_cate = estimate_cate, dr_estimate = dr_estimate, aiptw = aiptw
)
# bootstrap
results <- boot_og(fut_globals)
boot_og <- function(fut_globals) {
# instantiate bootstrap storage structure
boots <- tibble(quantile=numeric(),
em=character(),
cate=numeric(),
cate_se=numeric())
# if conducting bootstrap hypothesis test, instantiate storage structure for observed CATEs
if (test == "BH") {
bh_cates <- tibble(quantile = numeric(),
em = character(),
o_cate = numeric(),
o_cate_se = numeric())
}
ate_estimate <- estimate_ate(data, y, z, X, estimand, family, estimation_method, propensity)
ate <- ate_estimate[1]
ate_confint <- ate_estimate[2:3]
# main computation
# initialize counters and time storage vectors
init <- numeric()
end <- numeric()
em_counter <- 0
b_counter <- 0
n_ems <- ncol(ems)
n_quantiles <- length(quantiles)
n_iter <- n_ems * n_quantiles * B
# if performing Cochran's Q test before bootstrapping, create list of effect modifiers
if (test == "PQ") em_rejectT <- character(0)
for (em in names(ems)) {
em_counter <- em_counter + 1
q_counter <- 0
adj_X <- generate_adj_X(em, X, P)
# estimate observed CATEs if conducting bootstrap hypothesis test or prior Cochran's Q test
if (test == "BH" | test == "PQ") {
mod_cate0 <- glm(y ~ z + as.matrix(adj_X), family=family, subset=which(get(em, ems) == 0))
mod_cate100 <- glm(y ~ z + as.matrix(adj_X), family=family, subset=which(get(em, ems) == 1))
if (test == "BH") {
bh_cates <- bh_cates %>% add_row(
quantile = c(0,100),
em = em,
o_cate = c(mod_cate0$coefficients["z"], mod_cate100$coefficients["z"]),
o_cate_se = c(summary(mod_cate0)$coefficients["z", "Std. Error"],
summary(mod_cate100)$coefficients["z", "Std. Error"]))
} else if (test == "PQ") {
PQ_rejectT <- cochrans_q_het(ate = ate,
cate0 = mod_cate0$coefficients["z"],
cate100 = mod_cate100$coefficients["z"],
se0 = summary(mod_cate0)$coefficients["z", "Std. Error"],
se100 = summary(mod_cate100)$coefficients["z", "Std. Error"],
estimand = estimand)[2] < alpha
if (PQ_rejectT) {
em_rejectT <- c(em_rejectT, em)
} else {
next
}
}
}
for (q in quantiles) {
q_counter <- q_counter + 1
for (b in 1:B) {
b_counter <- b_counter + 1
init <- c(init, Sys.time())
# bootstrap CATE data according to quantiles
inem <- which(get(em, ems) == 1)
outem <- which(get(em, ems) == 0)
ind_inem <- sample(inem, size = round(nrow(P) * q/100), replace = T)
ind_outem <- sample(outem, size = round(nrow(P) * (100-q)/100), replace = T)
cate_ind <- c(ind_inem, ind_outem)
# create outcome model and add estimated CATE (and SE) to bootstrap storage structure
cate_estimate <- estimate_cate(data, y, z, adj_X, cate_ind, estimand, family, estimation_method, propensity)
cate <- cate_estimate[1]
cate_se <- cate_estimate[2]
boots <- boots %>% add_row(
quantile = q,
em = em,
cate = cate_estimate[1],
cate_se = cate_estimate[2]
)
end <- c(end, Sys.time())
time <- round(seconds_to_period(sum(end - init)), 0)
est <- n_iter*(mean(end[end != 0] - init[init != 0])) - time
remaining <- round(seconds_to_period(est), 0)
percent <- b_counter/n_iter * 100
# p(message = sprintf("em: %s | quantile: %d | bootstrap : %d", em, q, b))
# update
cat(paste0(sprintf('\r[%-50s] %d%%',
paste(rep('=', percent / 2), collapse = ''),
floor(percent)),
" | Effect Modifier:", em_counter, "/", n_ems,
" | Quantile:", q_counter, "/", n_quantiles,
" | Bootstrap: ", b, "/", B, "     "))
}
}
}
# calculate means/medians, bootstrap confidence intervals
if (estimand == "or" | estimand == "rr") {
statistics <- boots %>%
group_by(quantile, em) %>%
summarise(mean_cate = mean(exp(cate)),
median_cate = median(exp(cate)),
cate_lp_se = bse(cate),
cate_ci_lwr = quantile(exp(cate), probs = 0.025),
cate_ci_upr = quantile(exp(cate), probs = 0.975))
} else if (estimand == "rd") {
statistics <- boots %>%
group_by(quantile, em) %>%
summarise(mean_cate = mean(cate),
median_cate = median(cate),
cate_lp_se = bse(cate),
cate_ci_lwr = quantile(cate, probs = 0.025),
cate_ci_upr = quantile(cate, probs = 0.975))
} else {}
# make CATEs solid colors on plot if they are outside the ATE 95% CI
statistics <- statistics %>%
mutate(cate_visible = case_when(median_cate > ate_confint[2] ~ T,
median_cate < ate_confint[1] ~ T,
T ~ F))
# conduct heterogeneity test
## check for overlapping of CIs
if (test == "CI") {
### candidates reject null hypothesis of homogeneity if at least one of the 0 or 100 quantile CIs do not overlap with the ATE CI
em_rejectT <- statistics %>%
filter(quantile == 0 | quantile == 100) %>%
mutate(cate_ci_rejectT = case_when(cate_ci_lwr > ate_confint[2] ~ T,
cate_ci_upr < ate_confint[1] ~ T,
T ~ F)) %>%
filter(cate_ci_rejectT == T) %>%
pull(em) %>%
unique()
# conduct Cochran's Q test
} else if (test == "Q") {
em_rejectT <- statistics %>%
group_by(em) %>%
filter(quantile == min(quantiles) | quantile == max(quantiles)) %>%
arrange(quantile) %>%
summarise(Q_rejectT = cochrans_q_het(ate = ate,
cate0 = first(mean_cate),
cate100 = last(mean_cate),
se0 = first(cate_lp_se),
se100 = last(cate_lp_se),
estimand = estimand)[2] < alpha) %>%
filter(Q_rejectT == T) %>%
pull(em)
# conduct bootstrap hypothesis one-sample test
} else if (test == "BH") {
bh_cates <- bh_cates %>%
mutate(t = case_when(family == "gaussian" ~ (o_cate-ate)/o_cate_se,
family == "binomial" ~ (o_cate-log(ate))/o_cate_se))
em_rejectT <- boots %>%
left_join(., bh_cates) %>%
filter(quantile == 0 | quantile == 100) %>%
mutate(boot_t = (cate-o_cate)/cate_se) %>%
group_by(quantile, em) %>%
summarise(bh_reject_pval = mean(abs(boot_t) > abs(t))) %>%
mutate(bh_rejectT = bh_reject_pval < alpha) %>%
filter(bh_rejectT == T) %>%
pull(em) %>%
unique()
} else {}
result <- list(
ate = ate,
ate_confint = ate_confint,
statistics = statistics,
em_rejectT = em_rejectT
)
return(result)
}
# bootstrap
results <- boot_og(fut_globals)
# bootstrap
results <- boot_og(fut_globals)
# instantiate bootstrap storage structure
boots <- tibble(quantile=numeric(),
em=character(),
cate=numeric(),
cate_se=numeric())
# if conducting bootstrap hypothesis test, instantiate storage structure for observed CATEs
if (test == "BH") {
bh_cates <- tibble(quantile = numeric(),
em = character(),
o_cate = numeric(),
o_cate_se = numeric())
}
ate_estimate <- estimate_ate(data, y, z, X, estimand, family, estimation_method, propensity)
ate <- ate_estimate[1]
ate_confint <- ate_estimate[2:3]
# main computation
# initialize counters and time storage vectors
init <- numeric()
end <- numeric()
em_counter <- 0
b_counter <- 0
n_ems <- ncol(ems)
n_quantiles <- length(quantiles)
n_iter <- n_ems * n_quantiles * B
# if performing Cochran's Q test before bootstrapping, create list of effect modifiers
if (test == "PQ") em_rejectT <- character(0)
for (em in names(ems)) {
em_counter <- em_counter + 1
q_counter <- 0
adj_X <- generate_adj_X(em, X, P)
# estimate observed CATEs if conducting bootstrap hypothesis test or prior Cochran's Q test
if (test == "BH" | test == "PQ") {
mod_cate0 <- glm(y ~ z + as.matrix(adj_X), family=family, subset=which(get(em, ems) == 0))
mod_cate100 <- glm(y ~ z + as.matrix(adj_X), family=family, subset=which(get(em, ems) == 1))
if (test == "BH") {
bh_cates <- bh_cates %>% add_row(
quantile = c(0,100),
em = em,
o_cate = c(mod_cate0$coefficients["z"], mod_cate100$coefficients["z"]),
o_cate_se = c(summary(mod_cate0)$coefficients["z", "Std. Error"],
summary(mod_cate100)$coefficients["z", "Std. Error"]))
} else if (test == "PQ") {
PQ_rejectT <- cochrans_q_het(ate = ate,
cate0 = mod_cate0$coefficients["z"],
cate100 = mod_cate100$coefficients["z"],
se0 = summary(mod_cate0)$coefficients["z", "Std. Error"],
se100 = summary(mod_cate100)$coefficients["z", "Std. Error"],
estimand = estimand)[2] < alpha
if (PQ_rejectT) {
em_rejectT <- c(em_rejectT, em)
} else {
next
}
}
}
for (q in quantiles) {
q_counter <- q_counter + 1
for (b in 1:B) {
b_counter <- b_counter + 1
init <- c(init, Sys.time())
# bootstrap CATE data according to quantiles
inem <- which(get(em, ems) == 1)
outem <- which(get(em, ems) == 0)
ind_inem <- sample(inem, size = round(nrow(P) * q/100), replace = T)
ind_outem <- sample(outem, size = round(nrow(P) * (100-q)/100), replace = T)
cate_ind <- c(ind_inem, ind_outem)
# create outcome model and add estimated CATE (and SE) to bootstrap storage structure
cate_estimate <- estimate_cate(data, y, z, adj_X, cate_ind, estimand, family, estimation_method, propensity)
cate <- cate_estimate[1]
cate_se <- cate_estimate[2]
boots <- boots %>% add_row(
quantile = q,
em = em,
cate = cate_estimate[1],
cate_se = cate_estimate[2]
)
end <- c(end, Sys.time())
time <- round(seconds_to_period(sum(end - init)), 0)
est <- n_iter*(mean(end[end != 0] - init[init != 0])) - time
remaining <- round(seconds_to_period(est), 0)
percent <- b_counter/n_iter * 100
# p(message = sprintf("em: %s | quantile: %d | bootstrap : %d", em, q, b))
# update
cat(paste0(sprintf('\r[%-50s] %d%%',
paste(rep('=', percent / 2), collapse = ''),
floor(percent)),
" | Effect Modifier:", em_counter, "/", n_ems,
" | Quantile:", q_counter, "/", n_quantiles,
" | Bootstrap: ", b, "/", B, "     "))
}
}
}
names(ems)
ems
ems <- create_ems_output$ems
ems
library(profvis)
profvis(boot_og(fut_globals))
profvis(boot_og(fut_globals))
boot_og(fut_globals)
# source files
source("../helper-functions.R")
source("create_ems.R")
source("boot_og.R")
# load in data/parameters
data <- read_csv("~/benmarhnia-lab/data_droughts_malnutrition_101822.csv")
y <- pull(data, stunted)
z <- pull(data, drought)
X <- select(data, -c(stunted, drought))
P <- select(X, education_none, mass_media, rural_residence)
quantiles <- c(0, 50, 100)
B <- 1
estimand <- "rd"
estimation_method <- "lr"
test <- "BH"
alpha <- 0.05
if (estimand == "or") {
family <- "binomial"
} else if (estimand == "rd") {
family <- "gaussian"
} else {}
if (estimation_method == "iptw" | estimation_method == "dr") {
propensity <- ipweights(data, X, z)
} else if (estimation_method == "lr") {
propensity <- rep(1, length(z))
} else {}
# create ems and clean P
create_ems_output <- create_ems(P)
P <- create_ems_output$P
ems <- create_ems_output$ems
fut_globals <- list(
data = data, y = y, z = z, X = X, P = P, ems = ems,
quantiles = quantiles, B = B, estimand = estimand, test = test, estimation_method = estimation_method, alpha = alpha, family = family, propensity = propensity,
bse = bse, cochrans_q_het = cochrans_q_het, ipweights = ipweights, generate_adj_X = generate_adj_X, estimate_ate = estimate_ate, estimate_cate = estimate_cate, dr_estimate = dr_estimate, aiptw = aiptw
)
# bootstrap
results <- boot_og(fut_globals)
profvis(boot_og(fut_globals))
install.packages("microbenchmark")
library(microbenchmark)
# method to be run locally for the purposes of testing parallel processing
libraries <- c("DT", "tidyverse", "WeightIt", "sandwich", "lmtest", "boot", "plotly", "promises", "future", "foreach", "doFuture", "progressr", "data.table", "parallel", "future.apply", "stringr", "dplyr")
lapply(libraries, require, character.only = TRUE)
# source files
source("../helper-functions.R")
source("create_ems.R")
source("boot_og.R")
# load in data/parameters
data <- read_csv("~/benmarhnia-lab/data_droughts_malnutrition_101822.csv")
y <- pull(data, stunted)
z <- pull(data, drought)
X <- select(data, -c(stunted, drought))
P <- select(X, education_none, mass_media, rural_residence)
quantiles <- c(0, 50, 100)
B <- 10
estimand <- "rd"
estimation_method <- "lr"
test <- "BH"
alpha <- 0.05
if (estimand == "or") {
family <- "binomial"
} else if (estimand == "rd") {
family <- "gaussian"
} else {}
if (estimation_method == "iptw" | estimation_method == "dr") {
propensity <- ipweights(data, X, z)
} else if (estimation_method == "lr") {
propensity <- rep(1, length(z))
} else {}
# create ems and clean P
create_ems_output <- create_ems(P)
P <- create_ems_output$P
ems <- create_ems_output$ems
fut_globals <- list(
data = data, y = y, z = z, X = X, P = P, ems = ems,
quantiles = quantiles, B = B, estimand = estimand, test = test, estimation_method = estimation_method, alpha = alpha, family = family, propensity = propensity,
bse = bse, cochrans_q_het = cochrans_q_het, ipweights = ipweights, generate_adj_X = generate_adj_X, estimate_ate = estimate_ate, estimate_cate = estimate_cate, dr_estimate = dr_estimate, aiptw = aiptw
)
# bootstrap
results1 <- boot_og(fut_globals)
microbenchmark(
boot_og(fut_globals),
times = 3
)
source("boot_oglapply.R")
microbenchmark(
boot_oglapply(fut_globals),
times = 3
)
source("boot_oglapply.R")
microbenchmark(
boot_oglapply(fut_globals),
times = 3
)
profvis(boot_oglapply(fut_globals))
B <- 1
fut_globals <- list(
data = data, y = y, z = z, X = X, P = P, ems = ems,
quantiles = quantiles, B = B, estimand = estimand, test = test, estimation_method = estimation_method, alpha = alpha, family = family, propensity = propensity,
bse = bse, cochrans_q_het = cochrans_q_het, ipweights = ipweights, generate_adj_X = generate_adj_X, estimate_ate = estimate_ate, estimate_cate = estimate_cate, dr_estimate = dr_estimate, aiptw = aiptw
)
profvis(boot_oglapply(fut_globals))
t <- lapply(names(ems), function(em) {print(em)})
t()
source("boot_oglapply.R")
profvis(boot_oglapply(fut_globals))
microbenchmark(
boot_oglapply(fut_globals),
times = 3
)
B <- 10
microbenchmark(
boot_oglapply(fut_globals),
times = 3
)
fut_globals <- list(
data = data, y = y, z = z, X = X, P = P, ems = ems,
quantiles = quantiles, B = B, estimand = estimand, test = test, estimation_method = estimation_method, alpha = alpha, family = family, propensity = propensity,
bse = bse, cochrans_q_het = cochrans_q_het, ipweights = ipweights, generate_adj_X = generate_adj_X, estimate_ate = estimate_ate, estimate_cate = estimate_cate, dr_estimate = dr_estimate, aiptw = aiptw
)
microbenchmark(
boot_oglapply(fut_globals),
times = 3
)
source("boot_flff.R")
source("boot_flff.R")
microbenchmark(
boot_flff(fut_globals),
times = 3
)
source("boot_flff.R")
microbenchmark(
boot_flff(fut_globals),
times = 3
)
source("boot_flff.R")
microbenchmark(
boot_flff(fut_globals),
times = 3
)
source("boot_flff.R")
microbenchmark(
boot_flff(fut_globals),
times = 3
)
source("boot_flff.R")
microbenchmark(
boot_flff(fut_globals),
times = 3
)
showConnections()
source("boot_flll.R")
microbenchmark(
boot_flll(fut_globals),
times = 3
)
microbenchmark(
boot_flll(fut_globals),
times = 3
)
source("boot_flll.R")
microbenchmark(
boot_flll(fut_globals),
times = 3
)
